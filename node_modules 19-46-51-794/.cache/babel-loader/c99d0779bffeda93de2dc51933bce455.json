{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { isEnumFieldType, isGraphQLScalarType, isPredicateObj, isSchemaModel, isTargetNameAssociation, isNonModelFieldType, OpType } from '../types';\nimport { exhaustiveCheck } from '../util';\nvar GraphQLOperationType;\n\n(function (GraphQLOperationType) {\n  GraphQLOperationType[\"LIST\"] = \"query\";\n  GraphQLOperationType[\"CREATE\"] = \"mutation\";\n  GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n  GraphQLOperationType[\"DELETE\"] = \"mutation\";\n  GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\n\nexport var TransformerMutationType;\n\n(function (TransformerMutationType) {\n  TransformerMutationType[\"CREATE\"] = \"Create\";\n  TransformerMutationType[\"UPDATE\"] = \"Update\";\n  TransformerMutationType[\"DELETE\"] = \"Delete\";\n  TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\n\nvar dummyMetadata = {\n  _version: undefined,\n  _lastChangedAt: undefined,\n  _deleted: undefined\n};\nvar metadataFields = Object.keys(dummyMetadata);\nexport function getMetadataFields() {\n  return metadataFields;\n}\nexport function generateSelectionSet(namespace, modelDefinition) {\n  var scalarFields = getScalarFields(modelDefinition);\n  var nonModelFields = getNonModelFields(namespace, modelDefinition);\n  var implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n  var scalarAndMetadataFields = Object.values(scalarFields).map(function (_a) {\n    var name = _a.name;\n    return name;\n  }).concat(implicitOwnerField).concat(nonModelFields);\n\n  if (isSchemaModel(modelDefinition)) {\n    scalarAndMetadataFields = scalarAndMetadataFields.concat(getMetadataFields()).concat(getConnectionFields(modelDefinition));\n  }\n\n  var result = scalarAndMetadataFields.join('\\n');\n  return result;\n}\n\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n  var ownerFields = getOwnerFields(modelDefinition);\n\n  if (!scalarFields.owner && ownerFields.includes('owner')) {\n    return ['owner'];\n  }\n\n  return [];\n}\n\nfunction getOwnerFields(modelDefinition) {\n  var ownerFields = [];\n\n  if (isSchemaModel(modelDefinition) && modelDefinition.attributes) {\n    modelDefinition.attributes.forEach(function (attr) {\n      if (attr.properties && attr.properties.rules) {\n        var rule = attr.properties.rules.find(function (rule) {\n          return rule.allow === 'owner';\n        });\n\n        if (rule && rule.ownerField) {\n          ownerFields.push(rule.ownerField);\n        }\n      }\n    });\n  }\n\n  return ownerFields;\n}\n\nfunction getScalarFields(modelDefinition) {\n  var fields = modelDefinition.fields;\n  var result = Object.values(fields).filter(function (field) {\n    if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n      return true;\n    }\n\n    return false;\n  }).reduce(function (acc, field) {\n    acc[field.name] = field;\n    return acc;\n  }, {});\n  return result;\n}\n\nfunction getConnectionFields(modelDefinition) {\n  var result = [];\n  Object.values(modelDefinition.fields).filter(function (_a) {\n    var association = _a.association;\n    return association && Object.keys(association).length;\n  }).forEach(function (_a) {\n    var name = _a.name,\n        association = _a.association;\n    var connectionType = association.connectionType;\n\n    switch (connectionType) {\n      case 'HAS_ONE':\n      case 'HAS_MANY':\n        // Intentionally blank\n        break;\n\n      case 'BELONGS_TO':\n        if (isTargetNameAssociation(association)) {\n          result.push(name + \" { id _deleted }\");\n        }\n\n        break;\n\n      default:\n        exhaustiveCheck(connectionType);\n    }\n  });\n  return result;\n}\n\nfunction getNonModelFields(namespace, modelDefinition) {\n  var result = [];\n  Object.values(modelDefinition.fields).forEach(function (_a) {\n    var name = _a.name,\n        type = _a.type;\n\n    if (isNonModelFieldType(type)) {\n      var typeDefinition = namespace.nonModels[type.nonModel];\n      var scalarFields = Object.values(getScalarFields(typeDefinition)).map(function (_a) {\n        var name = _a.name;\n        return name;\n      });\n      var nested_1 = [];\n      Object.values(typeDefinition.fields).forEach(function (field) {\n        var type = field.type,\n            name = field.name;\n\n        if (isNonModelFieldType(type)) {\n          var typeDefinition_1 = namespace.nonModels[type.nonModel];\n          nested_1.push(name + \" { \" + generateSelectionSet(namespace, typeDefinition_1) + \" }\");\n        }\n      });\n      result.push(name + \" { \" + scalarFields.join(' ') + \" \" + nested_1.join(' ') + \" }\");\n    }\n  });\n  return result;\n}\n\nexport function getAuthorizationRules(modelDefinition) {\n  // Searching for owner authorization on attributes\n  var authConfig = [].concat(modelDefinition.attributes).find(function (attr) {\n    return attr && attr.type === 'auth';\n  });\n  var _a = (authConfig || {}).properties,\n      _b = (_a === void 0 ? {} : _a).rules,\n      rules = _b === void 0 ? [] : _b;\n  var resultRules = []; // Multiple rules can be declared for allow: owner\n\n  rules.forEach(function (rule) {\n    // setting defaults for backwards compatibility with old cli\n    var _a = rule.identityClaim,\n        identityClaim = _a === void 0 ? 'cognito:username' : _a,\n        _b = rule.ownerField,\n        ownerField = _b === void 0 ? 'owner' : _b,\n        _c = rule.operations,\n        operations = _c === void 0 ? ['create', 'update', 'delete', 'read'] : _c,\n        _d = rule.provider,\n        provider = _d === void 0 ? 'userPools' : _d,\n        _e = rule.groupClaim,\n        groupClaim = _e === void 0 ? 'cognito:groups' : _e,\n        _f = rule.allow,\n        authStrategy = _f === void 0 ? 'iam' : _f,\n        _g = rule.groups,\n        groups = _g === void 0 ? [] : _g;\n    var isReadAuthorized = operations.includes('read');\n    var isOwnerAuth = authStrategy === 'owner';\n\n    if (!isReadAuthorized && !isOwnerAuth) {\n      return;\n    }\n\n    var authRule = {\n      identityClaim: identityClaim,\n      ownerField: ownerField,\n      provider: provider,\n      groupClaim: groupClaim,\n      authStrategy: authStrategy,\n      groups: groups,\n      areSubscriptionsPublic: false\n    };\n\n    if (isOwnerAuth) {\n      // look for the subscription level override\n      // only pay attention to the public level\n      var modelConfig = [].concat(modelDefinition.attributes).find(function (attr) {\n        return attr && attr.type === 'model';\n      }); // find the subscriptions level. ON is default\n\n      var _h = (modelConfig || {}).properties,\n          _j = (_h === void 0 ? {} : _h).subscriptions,\n          _k = (_j === void 0 ? {} : _j).level,\n          level = _k === void 0 ? 'on' : _k; // treat subscriptions as public for owner auth with unprotected reads\n      // when `read` is omitted from `operations`\n\n      authRule.areSubscriptionsPublic = !operations.includes('read') || level === 'public';\n    }\n\n    if (isOwnerAuth) {\n      // owner rules has least priority\n      resultRules.push(authRule);\n      return;\n    }\n\n    resultRules.unshift(authRule);\n  });\n  return resultRules;\n}\nexport function buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField) {\n  var selectionSet = generateSelectionSet(namespace, modelDefinition);\n  var typeName = modelDefinition.name,\n      pluralTypeName = modelDefinition.pluralName;\n  var opName = \"on\" + transformerMutationType + typeName;\n  var docArgs = '';\n  var opArgs = '';\n\n  if (isOwnerAuthorization) {\n    docArgs = \"($\" + ownerField + \": String!)\";\n    opArgs = \"(\" + ownerField + \": $\" + ownerField + \")\";\n  }\n\n  return [transformerMutationType, opName, \"subscription operation\" + docArgs + \"{\\n\\t\\t\\t\" + opName + opArgs + \"{\\n\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t}\\n\\t\\t}\"];\n}\nexport function buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n  var selectionSet = generateSelectionSet(namespace, modelDefinition);\n  var typeName = modelDefinition.name,\n      pluralTypeName = modelDefinition.pluralName;\n  var operation;\n  var documentArgs = ' ';\n  var operationArgs = ' ';\n  var transformerMutationType;\n\n  switch (graphQLOpType) {\n    case 'LIST':\n      operation = \"sync\" + pluralTypeName;\n      documentArgs = \"($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model\" + typeName + \"FilterInput)\";\n      operationArgs = '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n      selectionSet = \"items {\\n\\t\\t\\t\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tnextToken\\n\\t\\t\\t\\t\\t\\tstartedAt\";\n      break;\n\n    case 'CREATE':\n      operation = \"create\" + typeName;\n      documentArgs = \"($input: Create\" + typeName + \"Input!)\";\n      operationArgs = '(input: $input)';\n      transformerMutationType = TransformerMutationType.CREATE;\n      break;\n\n    case 'UPDATE':\n      operation = \"update\" + typeName;\n      documentArgs = \"($input: Update\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.UPDATE;\n      break;\n\n    case 'DELETE':\n      operation = \"delete\" + typeName;\n      documentArgs = \"($input: Delete\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.DELETE;\n      break;\n\n    case 'GET':\n      operation = \"get\" + typeName;\n      documentArgs = \"($id: ID!)\";\n      operationArgs = '(id: $id)';\n      transformerMutationType = TransformerMutationType.GET;\n      break;\n\n    default:\n      exhaustiveCheck(graphQLOpType);\n  }\n\n  return [[transformerMutationType, operation, GraphQLOperationType[graphQLOpType] + \" operation\" + documentArgs + \"{\\n\\t\\t\" + operation + operationArgs + \"{\\n\\t\\t\\t\" + selectionSet + \"\\n\\t\\t}\\n\\t}\"]];\n}\nexport function createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n  var operation;\n\n  switch (opType) {\n    case OpType.INSERT:\n      operation = TransformerMutationType.CREATE;\n      break;\n\n    case OpType.UPDATE:\n      operation = TransformerMutationType.UPDATE;\n      break;\n\n    case OpType.DELETE:\n      operation = TransformerMutationType.DELETE;\n      break;\n\n    default:\n      exhaustiveCheck(opType);\n  }\n\n  var mutationEvent = modelInstanceCreator(MutationEventConstructor, __assign(__assign({}, id ? {\n    id: id\n  } : {}), {\n    data: JSON.stringify(element),\n    modelId: element.id,\n    model: model.name,\n    operation: operation,\n    condition: JSON.stringify(condition)\n  }));\n  return mutationEvent;\n}\nexport function predicateToGraphQLCondition(predicate) {\n  var result = {};\n\n  if (!predicate || !Array.isArray(predicate.predicates)) {\n    return result;\n  }\n\n  predicate.predicates.forEach(function (p) {\n    var _a;\n\n    if (isPredicateObj(p)) {\n      var field = p.field,\n          operator = p.operator,\n          operand = p.operand;\n\n      if (field === 'id') {\n        return;\n      }\n\n      result[field] = (_a = {}, _a[operator] = operand, _a);\n    } else {\n      result[p.type] = predicateToGraphQLCondition(p);\n    }\n  });\n  return result;\n}\nexport function predicateToGraphQLFilter(predicatesGroup) {\n  var result = {};\n\n  if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n    return result;\n  }\n\n  var type = predicatesGroup.type,\n      predicates = predicatesGroup.predicates;\n  var isList = type === 'and' || type === 'or';\n  result[type] = isList ? [] : {};\n\n  var appendToFilter = function (value) {\n    return isList ? result[type].push(value) : result[type] = value;\n  };\n\n  predicates.forEach(function (predicate) {\n    var _a, _b;\n\n    if (isPredicateObj(predicate)) {\n      var field = predicate.field,\n          operator = predicate.operator,\n          operand = predicate.operand;\n      var gqlField = (_a = {}, _a[field] = (_b = {}, _b[operator] = operand, _b), _a);\n      appendToFilter(gqlField);\n      return;\n    }\n\n    appendToFilter(predicateToGraphQLFilter(predicate));\n  });\n  return result;\n}\nexport function getUserGroupsFromToken(token, rule) {\n  // validate token against groupClaim\n  var userGroups = token[rule.groupClaim] || [];\n\n  if (typeof userGroups === 'string') {\n    var parsedGroups = void 0;\n\n    try {\n      parsedGroups = JSON.parse(userGroups);\n    } catch (e) {\n      parsedGroups = userGroups;\n    }\n\n    userGroups = [].concat(parsedGroups);\n  }\n\n  return userGroups;\n}","map":{"version":3,"sources":["../../src/sync/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { isEnumFieldType, isGraphQLScalarType, isPredicateObj, isSchemaModel, isTargetNameAssociation, isNonModelFieldType, OpType, } from '../types';\nimport { exhaustiveCheck } from '../util';\nvar GraphQLOperationType;\n(function (GraphQLOperationType) {\n    GraphQLOperationType[\"LIST\"] = \"query\";\n    GraphQLOperationType[\"CREATE\"] = \"mutation\";\n    GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n    GraphQLOperationType[\"DELETE\"] = \"mutation\";\n    GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\nexport var TransformerMutationType;\n(function (TransformerMutationType) {\n    TransformerMutationType[\"CREATE\"] = \"Create\";\n    TransformerMutationType[\"UPDATE\"] = \"Update\";\n    TransformerMutationType[\"DELETE\"] = \"Delete\";\n    TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\nvar dummyMetadata = {\n    _version: undefined,\n    _lastChangedAt: undefined,\n    _deleted: undefined,\n};\nvar metadataFields = (Object.keys(dummyMetadata));\nexport function getMetadataFields() {\n    return metadataFields;\n}\nexport function generateSelectionSet(namespace, modelDefinition) {\n    var scalarFields = getScalarFields(modelDefinition);\n    var nonModelFields = getNonModelFields(namespace, modelDefinition);\n    var implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n    var scalarAndMetadataFields = Object.values(scalarFields)\n        .map(function (_a) {\n        var name = _a.name;\n        return name;\n    })\n        .concat(implicitOwnerField)\n        .concat(nonModelFields);\n    if (isSchemaModel(modelDefinition)) {\n        scalarAndMetadataFields = scalarAndMetadataFields\n            .concat(getMetadataFields())\n            .concat(getConnectionFields(modelDefinition));\n    }\n    var result = scalarAndMetadataFields.join('\\n');\n    return result;\n}\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n    var ownerFields = getOwnerFields(modelDefinition);\n    if (!scalarFields.owner && ownerFields.includes('owner')) {\n        return ['owner'];\n    }\n    return [];\n}\nfunction getOwnerFields(modelDefinition) {\n    var ownerFields = [];\n    if (isSchemaModel(modelDefinition) && modelDefinition.attributes) {\n        modelDefinition.attributes.forEach(function (attr) {\n            if (attr.properties && attr.properties.rules) {\n                var rule = attr.properties.rules.find(function (rule) { return rule.allow === 'owner'; });\n                if (rule && rule.ownerField) {\n                    ownerFields.push(rule.ownerField);\n                }\n            }\n        });\n    }\n    return ownerFields;\n}\nfunction getScalarFields(modelDefinition) {\n    var fields = modelDefinition.fields;\n    var result = Object.values(fields)\n        .filter(function (field) {\n        if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n            return true;\n        }\n        return false;\n    })\n        .reduce(function (acc, field) {\n        acc[field.name] = field;\n        return acc;\n    }, {});\n    return result;\n}\nfunction getConnectionFields(modelDefinition) {\n    var result = [];\n    Object.values(modelDefinition.fields)\n        .filter(function (_a) {\n        var association = _a.association;\n        return association && Object.keys(association).length;\n    })\n        .forEach(function (_a) {\n        var name = _a.name, association = _a.association;\n        var connectionType = association.connectionType;\n        switch (connectionType) {\n            case 'HAS_ONE':\n            case 'HAS_MANY':\n                // Intentionally blank\n                break;\n            case 'BELONGS_TO':\n                if (isTargetNameAssociation(association)) {\n                    result.push(name + \" { id _deleted }\");\n                }\n                break;\n            default:\n                exhaustiveCheck(connectionType);\n        }\n    });\n    return result;\n}\nfunction getNonModelFields(namespace, modelDefinition) {\n    var result = [];\n    Object.values(modelDefinition.fields).forEach(function (_a) {\n        var name = _a.name, type = _a.type;\n        if (isNonModelFieldType(type)) {\n            var typeDefinition = namespace.nonModels[type.nonModel];\n            var scalarFields = Object.values(getScalarFields(typeDefinition)).map(function (_a) {\n                var name = _a.name;\n                return name;\n            });\n            var nested_1 = [];\n            Object.values(typeDefinition.fields).forEach(function (field) {\n                var type = field.type, name = field.name;\n                if (isNonModelFieldType(type)) {\n                    var typeDefinition_1 = namespace.nonModels[type.nonModel];\n                    nested_1.push(name + \" { \" + generateSelectionSet(namespace, typeDefinition_1) + \" }\");\n                }\n            });\n            result.push(name + \" { \" + scalarFields.join(' ') + \" \" + nested_1.join(' ') + \" }\");\n        }\n    });\n    return result;\n}\nexport function getAuthorizationRules(modelDefinition) {\n    // Searching for owner authorization on attributes\n    var authConfig = []\n        .concat(modelDefinition.attributes)\n        .find(function (attr) { return attr && attr.type === 'auth'; });\n    var _a = (authConfig || {}).properties, _b = (_a === void 0 ? {} : _a).rules, rules = _b === void 0 ? [] : _b;\n    var resultRules = [];\n    // Multiple rules can be declared for allow: owner\n    rules.forEach(function (rule) {\n        // setting defaults for backwards compatibility with old cli\n        var _a = rule.identityClaim, identityClaim = _a === void 0 ? 'cognito:username' : _a, _b = rule.ownerField, ownerField = _b === void 0 ? 'owner' : _b, _c = rule.operations, operations = _c === void 0 ? ['create', 'update', 'delete', 'read'] : _c, _d = rule.provider, provider = _d === void 0 ? 'userPools' : _d, _e = rule.groupClaim, groupClaim = _e === void 0 ? 'cognito:groups' : _e, _f = rule.allow, authStrategy = _f === void 0 ? 'iam' : _f, _g = rule.groups, groups = _g === void 0 ? [] : _g;\n        var isReadAuthorized = operations.includes('read');\n        var isOwnerAuth = authStrategy === 'owner';\n        if (!isReadAuthorized && !isOwnerAuth) {\n            return;\n        }\n        var authRule = {\n            identityClaim: identityClaim,\n            ownerField: ownerField,\n            provider: provider,\n            groupClaim: groupClaim,\n            authStrategy: authStrategy,\n            groups: groups,\n            areSubscriptionsPublic: false,\n        };\n        if (isOwnerAuth) {\n            // look for the subscription level override\n            // only pay attention to the public level\n            var modelConfig = []\n                .concat(modelDefinition.attributes)\n                .find(function (attr) { return attr && attr.type === 'model'; });\n            // find the subscriptions level. ON is default\n            var _h = (modelConfig || {}).properties, _j = (_h === void 0 ? {} : _h).subscriptions, _k = (_j === void 0 ? {} : _j).level, level = _k === void 0 ? 'on' : _k;\n            // treat subscriptions as public for owner auth with unprotected reads\n            // when `read` is omitted from `operations`\n            authRule.areSubscriptionsPublic =\n                !operations.includes('read') || level === 'public';\n        }\n        if (isOwnerAuth) {\n            // owner rules has least priority\n            resultRules.push(authRule);\n            return;\n        }\n        resultRules.unshift(authRule);\n    });\n    return resultRules;\n}\nexport function buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField) {\n    var selectionSet = generateSelectionSet(namespace, modelDefinition);\n    var typeName = modelDefinition.name, pluralTypeName = modelDefinition.pluralName;\n    var opName = \"on\" + transformerMutationType + typeName;\n    var docArgs = '';\n    var opArgs = '';\n    if (isOwnerAuthorization) {\n        docArgs = \"($\" + ownerField + \": String!)\";\n        opArgs = \"(\" + ownerField + \": $\" + ownerField + \")\";\n    }\n    return [\n        transformerMutationType,\n        opName,\n        \"subscription operation\" + docArgs + \"{\\n\\t\\t\\t\" + opName + opArgs + \"{\\n\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t}\\n\\t\\t}\",\n    ];\n}\nexport function buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n    var selectionSet = generateSelectionSet(namespace, modelDefinition);\n    var typeName = modelDefinition.name, pluralTypeName = modelDefinition.pluralName;\n    var operation;\n    var documentArgs = ' ';\n    var operationArgs = ' ';\n    var transformerMutationType;\n    switch (graphQLOpType) {\n        case 'LIST':\n            operation = \"sync\" + pluralTypeName;\n            documentArgs = \"($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model\" + typeName + \"FilterInput)\";\n            operationArgs =\n                '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n            selectionSet = \"items {\\n\\t\\t\\t\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tnextToken\\n\\t\\t\\t\\t\\t\\tstartedAt\";\n            break;\n        case 'CREATE':\n            operation = \"create\" + typeName;\n            documentArgs = \"($input: Create\" + typeName + \"Input!)\";\n            operationArgs = '(input: $input)';\n            transformerMutationType = TransformerMutationType.CREATE;\n            break;\n        case 'UPDATE':\n            operation = \"update\" + typeName;\n            documentArgs = \"($input: Update\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.UPDATE;\n            break;\n        case 'DELETE':\n            operation = \"delete\" + typeName;\n            documentArgs = \"($input: Delete\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.DELETE;\n            break;\n        case 'GET':\n            operation = \"get\" + typeName;\n            documentArgs = \"($id: ID!)\";\n            operationArgs = '(id: $id)';\n            transformerMutationType = TransformerMutationType.GET;\n            break;\n        default:\n            exhaustiveCheck(graphQLOpType);\n    }\n    return [\n        [\n            transformerMutationType,\n            operation,\n            GraphQLOperationType[graphQLOpType] + \" operation\" + documentArgs + \"{\\n\\t\\t\" + operation + operationArgs + \"{\\n\\t\\t\\t\" + selectionSet + \"\\n\\t\\t}\\n\\t}\",\n        ],\n    ];\n}\nexport function createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n    var operation;\n    switch (opType) {\n        case OpType.INSERT:\n            operation = TransformerMutationType.CREATE;\n            break;\n        case OpType.UPDATE:\n            operation = TransformerMutationType.UPDATE;\n            break;\n        case OpType.DELETE:\n            operation = TransformerMutationType.DELETE;\n            break;\n        default:\n            exhaustiveCheck(opType);\n    }\n    var mutationEvent = modelInstanceCreator(MutationEventConstructor, __assign(__assign({}, (id ? { id: id } : {})), { data: JSON.stringify(element), modelId: element.id, model: model.name, operation: operation, condition: JSON.stringify(condition) }));\n    return mutationEvent;\n}\nexport function predicateToGraphQLCondition(predicate) {\n    var result = {};\n    if (!predicate || !Array.isArray(predicate.predicates)) {\n        return result;\n    }\n    predicate.predicates.forEach(function (p) {\n        var _a;\n        if (isPredicateObj(p)) {\n            var field = p.field, operator = p.operator, operand = p.operand;\n            if (field === 'id') {\n                return;\n            }\n            result[field] = (_a = {}, _a[operator] = operand, _a);\n        }\n        else {\n            result[p.type] = predicateToGraphQLCondition(p);\n        }\n    });\n    return result;\n}\nexport function predicateToGraphQLFilter(predicatesGroup) {\n    var result = {};\n    if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n        return result;\n    }\n    var type = predicatesGroup.type, predicates = predicatesGroup.predicates;\n    var isList = type === 'and' || type === 'or';\n    result[type] = isList ? [] : {};\n    var appendToFilter = function (value) {\n        return isList ? result[type].push(value) : (result[type] = value);\n    };\n    predicates.forEach(function (predicate) {\n        var _a, _b;\n        if (isPredicateObj(predicate)) {\n            var field = predicate.field, operator = predicate.operator, operand = predicate.operand;\n            var gqlField = (_a = {},\n                _a[field] = (_b = {}, _b[operator] = operand, _b),\n                _a);\n            appendToFilter(gqlField);\n            return;\n        }\n        appendToFilter(predicateToGraphQLFilter(predicate));\n    });\n    return result;\n}\nexport function getUserGroupsFromToken(token, rule) {\n    // validate token against groupClaim\n    var userGroups = token[rule.groupClaim] || [];\n    if (typeof userGroups === 'string') {\n        var parsedGroups = void 0;\n        try {\n            parsedGroups = JSON.parse(userGroups);\n        }\n        catch (e) {\n            parsedGroups = userGroups;\n        }\n        userGroups = [].concat(parsedGroups);\n    }\n    return userGroups;\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}